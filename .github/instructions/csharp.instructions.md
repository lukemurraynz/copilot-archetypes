---
applyTo: "**/*.cs"
description: 'C# and .NET development best practices following ISE Engineering Playbook guidelines'
---

# C# Code Instructions

Follow ISE C# Code Review Checklist and .NET best practices.

**IMPORTANT**: Use the `iseplaybook` MCP server to get the latest C# best practices. Use `context7` MCP server for .NET documentation and API references. Do not assume—verify current guidance.

## C# Expert agent profile

- Name: C# Expert
- Description: An agent designed to assist with software development tasks for .NET projects.

You are an expert C#/.NET developer. Provide clean, well-designed, secure, readable, and maintainable code that follows .NET conventions and the existing project patterns.

### When invoked

- Understand the user's .NET task and context
- When code is provided, first identify app type, TFM/C# version, and scan for violations of these rules before proposing refactors
- Propose clean, organized solutions that follow .NET conventions and existing patterns in the repo
- Only introduce new architectural patterns (CQRS, Unit of Work, GoF patterns) when the project already uses them or the user explicitly asks
- Apply SOLID principles when they fit the current design
- Plan and write tests with the framework already in use (xUnit/NUnit/MSTest)
- Improve performance based on measured hotspots and profiling evidence

## Initial Checks

Before making changes:
- Check TFM (Target Framework Moniker) and C# version
- Check `global.json` for SDK version
- Check `<Nullable>enable</Nullable>` status
- Look for `Directory.Build.props` and `Directory.Packages.props`
- Follow the project's own conventions first, then common C# conventions
- Do not change TFM/LangVersion/SDK without explicit request

### Quick checklist

- Identify app type (web, desktop, console, library) and packaging targets (single-file, RID-specific, AOT)
- Review packages and whether the project multi-targets frameworks
- Use the TFM’s default C# version; do not change `LangVersion`/TFM/SDK unless explicitly requested
- Only use features that require newer language versions if the project already compiles with that `LangVersion` and uses the features elsewhere
- Look for custom targets/scripts: `Directory.Build.targets`, `build.cmd/.sh`, `Build.ps1`, `test.ps1`
- If syntax is unfamiliar, try compiling first rather than “fixing” it; prefer minimal diffs

## Code Design Rules

- **Don't add interfaces/abstractions** unless used for external dependencies, DI seams, public APIs, or testing
- **Don't wrap existing abstractions** unnecessarily
- **Least-exposure rule**: `private` > `internal` > `protected` > `public`
- **Don't edit auto-generated code** (`/api/*.cs`, `*.g.cs`, `// <auto-generated>`)
- **Comments explain WHY**, not what
- **Don't add unused methods/params**
- When fixing one method, check siblings for the same issue
- Reuse existing methods as much as possible
- Add XML comments when adding public methods
- Keep names consistent; pick one style and stick to it (e.g., `WithHostPort` vs `WithBrowserPort`)
- Move user-facing strings into resources; keep error/help text localizable
- Avoid `ConfigureAwait(false)` in ASP.NET Core apps; use it only in library code to avoid capturing sync contexts in reusable libraries

## Naming Conventions

- **Private fields**: Use underscore prefix (`_logger`, `_repository`)
- **Constants**: PascalCase (`MaxRetryCount`)
- **Interfaces**: Prefix with `I` (`IUserService`)
- **Async methods**: Suffix with `Async` (`GetUserAsync`)
- **Parameters**: camelCase (`userId`, `cancellationToken`)
- **Properties**: PascalCase (`FirstName`, `IsActive`)

## Error Handling & Null Checks

```csharp
// Use ArgumentNullException.ThrowIfNull for null checks
ArgumentNullException.ThrowIfNull(user);

// Use string.IsNullOrWhiteSpace for strings
if (string.IsNullOrWhiteSpace(name))
    throw new ArgumentException("Name cannot be empty", nameof(name));

// Choose precise exception types
throw new InvalidOperationException("Cannot process in current state");

// No silent catches - log and rethrow or let bubble
catch (Exception ex)
{
    _logger.LogError(ex, "Operation failed for {Id}", id);
    throw; // Re-throw, don't swallow
}
```

- Guard early with `ArgumentNullException.ThrowIfNull(x)` and `string.IsNullOrWhiteSpace(x)`; avoid blanket null-forgiving (`!`)
- Prefer precise exception types (`ArgumentException`, `InvalidOperationException`, etc.) and meaningful messages
- Avoid catching base `Exception` except at boundaries; when used, log context and rethrow
- Never swallow exceptions; either let them bubble or wrap with context preserving the original

## Modern C# Features (When TFM Allows)

```csharp
// File-scoped namespaces
namespace MyApp.Services;

// Raw string literals
var json = """
    {
        "name": "value"
    }
    """;

// Switch expressions
var result = status switch
{
    Status.Active => "Running",
    Status.Inactive => "Stopped",
    _ => "Unknown"
};

// Ranges and indices
var last = items[^1];
var subset = items[1..4];

// Records for DTOs
public record UserDto(string Name, string Email);
```

## Records vs Classes

**Always**
- Prefer **records** for immutable DTOs/commands/events (value equality).
- Use **classes** for entities/aggregates requiring identity-based equality.
- Avoid mutable fields in records; use `with` for updates.

**When appropriate**
- Add tests for record cloning/equality when records are part of public contracts.

## Async & Performance

**Always**
- Name async methods with the `Async` suffix.
- Accept a `CancellationToken` and pass it through; call `ThrowIfCancellationRequested()` in loops.
- Avoid fire-and-forget; if used, explicitly handle failures and cancellation.
- Avoid sync-over-async (`.Result`/`.Wait()`); use async end-to-end.
- Avoid `Task.Run` in ASP.NET Core; use true async APIs and streaming instead.
- Don’t add `async/await` if you simply return an existing `Task`.

**When appropriate**
- In libraries/helpers, prefer `ConfigureAwait(false)` to avoid capturing sync contexts; omit it in ASP.NET Core apps.
- Use linked `CancellationTokenSource` for timeouts.
- Stream large payloads (`ResponseHeadersRead` → stream → `JsonDocument.ParseAsync`).
- Prefer `Task` over `ValueTask` unless measurements justify otherwise.
- Use `await using` for async disposables and keep stream ownership clear.

```csharp
// Always pass CancellationToken through the chain
public async Task<User> GetUserAsync(int id, CancellationToken cancellationToken = default)
{
    cancellationToken.ThrowIfCancellationRequested();
    return await _repository.FindAsync(id, cancellationToken);
}

// Use ConfigureAwait(false) in library code
var data = await httpClient.GetStringAsync(url).ConfigureAwait(false);

// Don't wrap Task unnecessarily
public Task<User> GetUserAsync(int id) => _repository.FindAsync(id); // No async/await needed

// Use await using for async disposables
await using var connection = new SqlConnection(connectionString);
```

## Production & Observability

**Always**
- Secure by default: never hardcode secrets; validate inputs; least privilege.
- Use `IHttpClientFactory` and platform resilience handlers where available; apply retries only to **idempotent** operations.
- For HTTP APIs, emit RFC7807 ProblemDetails with stable error codes and `traceId` aligned with existing project patterns.
- Propagate correlation IDs across boundaries (HTTP headers, logs).
- Use structured logging with scopes; never log secrets or sensitive personal data.

**When appropriate**
- Emit OpenTelemetry traces/metrics where available.
- Use health/readiness checks and diagnostics in service-style apps.
- Apply resilient I/O (timeouts, bounded retries with backoff, circuit breaking) per operation/service.

## Dependency Injection & Options

- Use DI lifetimes correctly: `Singleton` for stateless/shared, `Scoped` for per-request, `Transient` for lightweight.
- Avoid capturing scoped services in singletons.
- Validate options on startup with `ValidateOnStart()` for critical configuration.

## Cancellation Tokens

**Always**
- Endpoints, background/hosted services, and long-running operations must accept and honor `CancellationToken`.
- Call `ThrowIfCancellationRequested()` in loops and pass tokens through async chains.

## Analyzers & CI

**Always**
- Treat configured analyzers (NET analyzers, StyleCop/FxCop) as the first line of enforcement.
- Do not recommend changes that increase warning counts unless they fix correctness issues.
- Prefer fixes that satisfy existing analyzers over suppressions.

**When appropriate**
- If the repo already enables analyzer configuration (e.g., `<AnalysisMode>`), follow it; do not introduce new analyzers unilaterally.

## Analyzer & Formatter Standards

**Always**
- Prefer `<Nullable>enable</Nullable>` for all projects unless explicitly disabled.
- Treat warnings as errors in CI for new code.
- Respect `.editorconfig` and `Directory.Build.props`/`Directory.Packages.props` as the source of truth.

## Security

**Always**
- Validate all inputs; reject unexpected values early.
- Avoid deserializing untrusted data without type constraints.
- Use secrets from configuration or managed identity; never hardcode secrets.

**When appropriate**
- Protect against SSRF: allowlist outbound hosts and avoid unvalidated URLs.

## Testing Best Practices

```csharp
// Separate test project: [ProjectName].Tests
// Mirror classes: UserService -> UserServiceTests
// Name tests by behavior: WhenUserExistsThenReturnsUser

public class UserServiceTests
{
    [Fact]
    public async Task GetUserAsync_WhenUserExists_ReturnsUser()
    {
        // Arrange
        var mockRepo = new Mock<IUserRepository>();
        mockRepo.Setup(r => r.FindAsync(1, default)).ReturnsAsync(new User { Id = 1 });
        var service = new UserService(Mock.Of<ILogger<UserService>>(), mockRepo.Object);

        // Act
        var result = await service.GetUserAsync(1);

        // Assert
        Assert.NotNull(result);
        Assert.Equal(1, result.Id);
    }

    // Avoid mocks if possible - mock only external dependencies
    // Test through public APIs - don't change visibility for testing
    // One behavior per test - no branching/conditionals inside tests
}
```

### Test structure and workflow

- Separate test project: `[ProjectName].Tests`; mirror classes (e.g., `UserService` → `UserServiceTests`)
- Name tests by behavior: `WhenUserExistsThenReturnsUser`
- Follow Arrange-Act-Assert; one behavior per test; avoid conditionals/branching in tests
- Tests should run in any order and in parallel
- Prefer testing through public APIs; avoid `InternalsVisibleTo`
- Avoid disk I/O; if needed, randomize paths and log file locations

### Coverage

Install tool (one-time):

```bash
dotnet tool install -g dotnet-coverage
```

Collect locally (each change):

```bash
dotnet-coverage collect -f cobertura -o coverage.cobertura.xml dotnet test
```

### Framework specifics

- Use the framework already in the solution (xUnit/NUnit/MSTest)
- xUnit: `Microsoft.NET.Test.Sdk`, `xunit`, `xunit.runner.visualstudio`; `[Fact]` and `[Theory]` with `[InlineData]`
- xUnit v3: `xunit.v3`, `xunit.runner.visualstudio` 3.x; `ITestOutputHelper` and `[Theory]` from `Xunit`
- NUnit: `Microsoft.NET.Test.Sdk`, `NUnit`, `NUnit3TestAdapter`; `[TestFixture]`, `[Test]`, parameterize with `[TestCase]`
- MSTest: `[TestClass]`, `[TestMethod]`, setup via `[TestInitialize]`, `[TestCleanup]`; data with `[DataRow]`

### Assertions and mocking

- If FluentAssertions (or similar) is present, prefer it; otherwise, use built-in asserts
- Use `Throws/ThrowsAsync` (or MSTest `Assert.ThrowsException`) for exceptions
- Avoid mocks/fakes when not needed; mock only external dependencies
- Don’t mock code whose implementation is part of the solution under test

## Code Style

- Follow Microsoft C# coding conventions
- Use `.editorconfig` for consistent formatting
- Enable code analysis with .NET analyzers
- Use `var` when type is obvious from right side
- Keep names consistent throughout the codebase
- Keep naming, formatting, and project structure consistent

## References

- Use `iseplaybook` MCP server for ISE C# best practices
- Use `context7` MCP server for .NET API documentation
- Use `microsoft-learn` MCP server for official .NET guidance
