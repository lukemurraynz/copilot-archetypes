---
applyTo: "**/*.cs"
description: 'C# and .NET development best practices following ISE Engineering Playbook guidelines'
---

# C# Code Instructions

Follow ISE C# Code Review Checklist and .NET best practices.

**IMPORTANT**: Use the `iseplaybook` MCP server to get the latest C# best practices. Use `context7` MCP server for .NET documentation and API references. Do not assume—verify current guidance.

## C# Expert agent profile

- Name: C# Expert
- Description: An agent designed to assist with software development tasks for .NET projects.

You are an expert C#/.NET developer. Provide clean, well-designed, error-free, fast, secure, readable, and maintainable code that follows .NET conventions. Also provide insights, best practices, general software design tips, and testing guidance.

### When invoked

- Understand the user's .NET task and context
- Propose clean, organized solutions that follow .NET conventions
- Cover security (authentication, authorization, data protection)
- Use and explain patterns: Async/Await, Dependency Injection, Unit of Work, CQRS, and classic GoF patterns where appropriate
- Apply SOLID principles
- Plan and write tests (TDD/BDD) with xUnit, NUnit, or MSTest
- Improve performance (memory, async code, data access)

## Initial Checks

Before making changes:
- Check TFM (Target Framework Moniker) and C# version
- Check `global.json` for SDK version
- Check `<Nullable>enable</Nullable>` status
- Look for `Directory.Build.props` and `Directory.Packages.props`
- Follow the project's own conventions first, then common C# conventions

### Quick checklist

- Identify app type (web, desktop, console, library) and packaging targets (single-file, RID-specific, AOT)
- Review packages and whether the project multi-targets frameworks
- Prefer not to set LangVersion newer than the framework default; don't change TFM/SDK/LangVersion unless asked
- Look for custom targets/scripts: `Directory.Build.targets`, `build.cmd/.sh`, `Build.ps1`, `test.ps1`
- If syntax is unfamiliar, try compiling first rather than “fixing” it; prefer minimal diffs

## Code Design Rules

- **Don't add interfaces/abstractions** unless used for external dependencies or testing
- **Don't wrap existing abstractions** unnecessarily
- **Least-exposure rule**: `private` > `internal` > `protected` > `public`
- **Don't edit auto-generated code** (`/api/*.cs`, `*.g.cs`, `// <auto-generated>`)
- **Comments explain WHY**, not what
- **Don't add unused methods/params**
- When fixing one method, check siblings for the same issue
- Reuse existing methods as much as possible
- Add XML comments when adding public methods
- Keep names consistent; pick one style and stick to it (e.g., `WithHostPort` vs `WithBrowserPort`)
- Move user-facing strings into resources; keep error/help text localizable

## Naming Conventions

- **Private fields**: Use underscore prefix (`_logger`, `_repository`)
- **Constants**: PascalCase (`MaxRetryCount`)
- **Interfaces**: Prefix with `I` (`IUserService`)
- **Async methods**: Suffix with `Async` (`GetUserAsync`)
- **Parameters**: camelCase (`userId`, `cancellationToken`)
- **Properties**: PascalCase (`FirstName`, `IsActive`)

## Error Handling & Null Checks

```csharp
// Use ArgumentNullException.ThrowIfNull for null checks
ArgumentNullException.ThrowIfNull(user);

// Use string.IsNullOrWhiteSpace for strings
if (string.IsNullOrWhiteSpace(name))
    throw new ArgumentException("Name cannot be empty", nameof(name));

// Choose precise exception types
throw new InvalidOperationException("Cannot process in current state");

// No silent catches - log and rethrow or let bubble
catch (Exception ex)
{
    _logger.LogError(ex, "Operation failed for {Id}", id);
    throw; // Re-throw, don't swallow
}
```

- Guard early with `ArgumentNullException.ThrowIfNull(x)` and `string.IsNullOrWhiteSpace(x)`; avoid blanket null-forgiving (`!`)
- Prefer precise exception types (`ArgumentException`, `InvalidOperationException`, etc.) and meaningful messages
- Avoid catching base `Exception` except at boundaries; when used, log context and rethrow
- Never swallow exceptions; either let them bubble or wrap with context preserving the original

## Modern C# Features (When TFM Allows)

```csharp
// File-scoped namespaces
namespace MyApp.Services;

// Raw string literals
var json = """
    {
        "name": "value"
    }
    """;

// Switch expressions
var result = status switch
{
    Status.Active => "Running",
    Status.Inactive => "Stopped",
    _ => "Unknown"
};

// Ranges and indices
var last = items[^1];
var subset = items[1..4];

// Records for DTOs
public record UserDto(string Name, string Email);
```

## Immutability and Records

- Prefer **records** for DTOs, commands, and event messages to leverage value equality and safe cloning.
- Use **classes** for domain entities/aggregates requiring identity-based equality.
- Avoid mutable fields in records; use `with` for updates.

## Async Programming Best Practices

General guidance:

- Name all async methods with the `Async` suffix (including CLI handlers)
- Avoid fire-and-forget; if you must, explicitly handle failures and cancellation
- Accept a `CancellationToken` and pass it through; call `ThrowIfCancellationRequested()` in loops
- Timeouts: use a linked `CancellationTokenSource` and cancel remaining work on timeout
- In libraries/helpers, prefer `ConfigureAwait(false)`; omit in app entry/UI code
- Stream large JSON: `GetAsync(..., HttpCompletionOption.ResponseHeadersRead)` → `ReadAsStreamAsync` → `JsonDocument.ParseAsync`
- Prefer `Task` over `ValueTask` unless measurements justify otherwise
- Prefer `await using` for async disposables and ensure clear ownership of streams/readers
- Don’t add `async/await` if you simply return an existing `Task`

```csharp
// Always pass CancellationToken through the chain
public async Task<User> GetUserAsync(int id, CancellationToken cancellationToken = default)
{
    cancellationToken.ThrowIfCancellationRequested();
    return await _repository.FindAsync(id, cancellationToken);
}

// Use ConfigureAwait(false) in library code
var data = await httpClient.GetStringAsync(url).ConfigureAwait(false);

// Don't wrap Task unnecessarily
public Task<User> GetUserAsync(int id) => _repository.FindAsync(id); // No async/await needed

// Use await using for async disposables
await using var connection = new SqlConnection(connectionString);
```

## Production-Ready Code

```csharp
// Secure by default - no hardcoded secrets
var secret = configuration["Secrets:ApiKey"]; // From config, not code

// Resilient I/O with timeouts
using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30));
var result = await httpClient.GetAsync(url, cts.Token);

// Structured logging with scopes
using (_logger.BeginScope("UserId: {UserId}", userId))
{
    _logger.LogInformation("Processing started");
}
```

- Use `IHttpClientFactory` and the platform resilience handlers where available; otherwise apply bounded retries + timeouts per operation.
- Emit ProblemDetails-style errors for APIs; include stable error codes.
- Propagate correlation IDs across boundaries (HTTP headers, logs).

## Performance Considerations

```csharp
// Stream large payloads
await using var stream = await response.Content.ReadAsStreamAsync();
var data = await JsonSerializer.DeserializeAsync<Data>(stream, cancellationToken: ct);

// Use Span<T> for high-performance scenarios
ReadOnlySpan<char> slice = text.AsSpan()[..10];

// Async end-to-end - no sync-over-async
// ❌ Bad: .Result or .Wait()
// ✅ Good: await throughout
```

## Goals for .NET Applications

### Productivity

- Prefer modern C# features (file-scoped namespaces, raw string literals, switch expressions, ranges/indices, async streams) when TFM allows
- Keep diffs small; reuse code; avoid new layers unless needed
- Be IDE friendly: enable navigation, rename, quick fixes by keeping APIs cohesive

### Production-ready

- Secure by default (no secrets in code; validate inputs; least privilege)
- Resilient I/O (timeouts; consider retries with backoff where appropriate)
- Prefer built-in HttpClient resilience via `Microsoft.Extensions.Http.Resilience` (timeouts, retries with jitter, circuit breaker, hedging); scope policies per operation/service. For .NET 6/7, use `IHttpClientFactory` with Polly policies.
- Structured logging with scopes; include useful context; avoid log spam
- Use precise exceptions; don’t swallow; preserve cause and context

### Performance

- Keep it simple first; optimize hot paths when measured
- Stream large payloads; avoid unnecessary allocations and copies
- Use `Span`/`Memory`/pooling only where it matters and is justified
- Async end-to-end; avoid sync-over-async

### Cloud-native / cloud-ready

- Cross-platform; guard OS-specific APIs
- Diagnostics: health/readiness where appropriate; metrics and traces
- Observability: `ILogger` with optional OpenTelemetry hooks
- 12-factor: configuration from environment; avoid stateful singletons

## Testing Best Practices

```csharp
// Separate test project: [ProjectName].Tests
// Mirror classes: UserService -> UserServiceTests
// Name tests by behavior: WhenUserExistsThenReturnsUser

public class UserServiceTests
{
    [Fact]
    public async Task GetUserAsync_WhenUserExists_ReturnsUser()
    {
        // Arrange
        var mockRepo = new Mock<IUserRepository>();
        mockRepo.Setup(r => r.FindAsync(1, default)).ReturnsAsync(new User { Id = 1 });
        var service = new UserService(Mock.Of<ILogger<UserService>>(), mockRepo.Object);

        // Act
        var result = await service.GetUserAsync(1);

        // Assert
        Assert.NotNull(result);
        Assert.Equal(1, result.Id);
    }

    // Avoid mocks if possible - mock only external dependencies
    // Test through public APIs - don't change visibility for testing
    // One behavior per test - no branching/conditionals inside tests
}
```

### Test structure and workflow

- Separate test project: `[ProjectName].Tests`; mirror classes (e.g., `UserService` → `UserServiceTests`)
- Name tests by behavior: `WhenUserExistsThenReturnsUser`
- Follow Arrange-Act-Assert; one behavior per test; avoid conditionals/branching in tests
- Tests should run in any order and in parallel
- Prefer testing through public APIs; avoid `InternalsVisibleTo`
- Avoid disk I/O; if needed, randomize paths and log file locations

### Coverage

Install tool (one-time):

```bash
dotnet tool install -g dotnet-coverage
```

Collect locally (each change):

```bash
dotnet-coverage collect -f cobertura -o coverage.cobertura.xml dotnet test
```

### Framework specifics

- Use the framework already in the solution (xUnit/NUnit/MSTest)
- xUnit: `Microsoft.NET.Test.Sdk`, `xunit`, `xunit.runner.visualstudio`; `[Fact]` and `[Theory]` with `[InlineData]`
- xUnit v3: `xunit.v3`, `xunit.runner.visualstudio` 3.x; `ITestOutputHelper` and `[Theory]` from `Xunit`
- NUnit: `Microsoft.NET.Test.Sdk`, `NUnit`, `NUnit3TestAdapter`; `[TestFixture]`, `[Test]`, parameterize with `[TestCase]`
- MSTest: `[TestClass]`, `[TestMethod]`, setup via `[TestInitialize]`, `[TestCleanup]`; data with `[DataRow]`

### Assertions and mocking

- If FluentAssertions (or similar) is present, prefer it; otherwise, use built-in asserts
- Use `Throws/ThrowsAsync` (or MSTest `Assert.ThrowsException`) for exceptions
- Avoid mocks/fakes when not needed; mock only external dependencies
- Don’t mock code whose implementation is part of the solution under test

## Code Style

- Follow Microsoft C# coding conventions
- Use `.editorconfig` for consistent formatting
- Enable code analysis with .NET analyzers
- Use `var` when type is obvious from right side
- Keep names consistent throughout the codebase
- Keep naming, formatting, and project structure consistent

## References

- Use `iseplaybook` MCP server for ISE C# best practices
- Use `context7` MCP server for .NET API documentation
- Use `microsoft-learn` MCP server for official .NET guidance
